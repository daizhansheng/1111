

# 1.串行并发并行的区别

## 1.1串行执行
- **定义**：串行执行是指任务一个接一个地按顺序执行。每个任务完成后，才会开始下一个任务。
- **执行方式**：只有一个任务在执行，任务间没有重叠。
- **特点**：
  - **简单**：串行执行是最简单的执行方式，每个任务按顺序完成。
  - **效率低**：任务不能重叠执行，因此执行时间较长，尤其是当有多个任务时。
  - **无资源竞争**：因为任务是依次执行的，所以不会发生资源竞争问题。
- **示例**：假设有三个任务 \(A\)、\(B\)、\(C\)，它们必须按顺序执行：
  - 执行 \(A\) → 完成后执行 \(B\) → 完成后执行 \(C\)。

## 1.2并发执行
- **定义**：并发执行是指多个任务在同一时间段内进行，但是并不是同时执行。任务可以交替执行，每个任务可能在不同的时间片中运行。
- **执行方式**：在一个核心或处理器上，操作系统会在任务之间切换，给用户一种“同时执行”的感觉。多个任务并发执行是因为操作系统不断切换任务的执行。
- **特点**：
  - **任务交替执行**：任务并不是完全同时进行，而是操作系统或程序在多个任务之间切换，单核系统也可以实现并发。
  - **提高资源利用**：并发使得程序可以在等待某个任务（比如 I/O 操作）完成时，执行其他任务。
  - **I/O 密集型任务**：并发通常用于 I/O 密集型任务（如网络请求、磁盘读写等），在任务等待 I/O 时，程序可以执行其他任务，从而提高效率。
- **示例**：假设有任务 \(A\)、\(B\)、\(C\)，它们会被操作系统交替执行。例如：
  - 执行 \(A\) 的一部分 → 切换到 \(B\) → 切换到 \(C\) → 再次切换回 \(A\)，如此反复。

## 1.3并行执行
- **定义**：并行执行是指多个任务**真正同时执行**，并且每个任务在不同的处理器或多个核心上独立运行。
- **执行方式**：每个任务分配到不同的 CPU 核心上，同时进行计算，任务间没有等待。
- **特点**：
  - **多核或多处理器支持**：并行执行要求硬件支持，比如多个 CPU 核心或多个处理器。每个任务可以在独立的处理器上同时执行。
  - **适合 CPU 密集型任务**：并行非常适合需要大量计算的任务，可以显著提高计算效率。
  - **更高的执行效率**：与串行执行相比，并行执行可以显著减少任务的总体完成时间。
- **示例**：假设有任务 \(A\)、\(B\)、\(C\)，它们会在不同的处理器核心上同时执行：
  - \(A\) 在核心1上执行，\(B\) 在核心2上执行，\(C\) 在核心3上执行，它们同时进行，不需要等待。

## 1.4对比总结

| 执行方式 | 任务执行方式                                             | 资源使用        | 适用场景                                       |
| -------- | -------------------------------------------------------- | --------------- | ---------------------------------------------- |
| **串行** | 任务按顺序一个接一个执行                                 | 1个核心/处理器  | 任务不重叠，适用于较简单的、没有并行需求的任务 |
| **并发** | 任务交替执行，单核系统通过时间切换执行任务               | 1个核心/处理器  | 适合 I/O 密集型任务（如网络请求、文件读写）    |
| **并行** | 多个任务真正同时执行，每个任务在不同的处理器或核心上执行 | 多个核心/处理器 | 适合 CPU 密集型任务（如数据处理、大规模计算）  |

# 2.CPU密集型和IO密集型

## 2.1CPU 密集型任务

- **定义**：指那些主要依赖 CPU 进行大量计算的任务。CPU 密集型任务通常需要执行大量的数学运算、复杂的数据处理、加密解密、图像处理等。
- **特点**：CPU 密集型任务的性能主要取决于 CPU 的处理能力和核心数量，任务的执行过程基本上占用的是 CPU 资源。
- **示例**：科学计算、矩阵运算、图像处理、大量数据的排序或统计运算等。
- **适用方案**：多进程。因为 CPU 密集型任务需要多个 CPU 核心的处理能力，使用多进程可以让每个进程分配到不同的核心，充分利用多核 CPU。

## 2.2I/O 密集型任务
- **定义**：指那些主要受限于 I/O 操作（输入/输出）的任务，例如网络请求、文件读写、数据库操作等。这类任务的执行时间大部分花费在等待 I/O 设备响应上，而非 CPU 运算。
- **特点**：I/O 密集型任务通常会因为等待外部设备（如硬盘、网络）的响应而导致 CPU 闲置，因此 CPU 利用率低。
- **示例**：网络爬虫、读取和写入文件、大量网络数据传输等。
- **适用方案**：多线程或异步编程。由于 I/O 密集型任务常常在等待 I/O 操作完成，使用多线程或 `asyncio` 可以在等待期间执行其他任务，从而更有效地利用 CPU。

## 2.3对比总结
- **CPU 密集型任务**：大量计算，消耗 CPU 资源，适合多进程。
- **I/O 密集型任务**：大量 I/O 操作，等待时间长，适合多线程或异步。

根据任务的类型，可以选择合适的并发模式来提升性能。例如，Python 中的 `multiprocessing` 模块适合 CPU 密集型任务，而 `threading` 模块或 `asyncio` 则更适合 I/O 密集型任务。



# 3.多进程

## 3.1多进程的概念

在 Python 中，多进程（multiprocessing）是指利用多个进程同时执行任务，来实现并行计算的概念。Python 提供了 `multiprocessing` 模块，可以方便地创建和管理多个进程，尤其适合 CPU 密集型任务。多进程是一种绕过 Python 中的全局解释器锁（GIL）的方式，可以让 Python 程序利用多核 CPU 的全部计算能力。



Python 有一个全局解释器锁（GIL），限制了多线程的并行执行。特别是对于 CPU 密集型任务，使用多线程无法真正地并行运行，而多进程则不受 GIL 限制，每个进程都有独立的内存空间和 GIL。多进程适合需要大量计算的任务（如图像处理、大规模数据计算、科学计算等），可以显著提高程序的执行效率。

## 3.2多进程的创建

在 Python 中，多进程的创建和管理通常通过 `multiprocessing` 模块进行，特别是 `Process` 类。

```python
class multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, daemon=None)
```

==功能：==

`Process` 类用于创建和管理一个新的进程。进程是操作系统资源的单独实例，它包含程序的代码和运行时状态。在多进程模型中，每个进程独立运行，并且有自己的内存空间。

==参数：==

- **group**：目前必须为 `None`，是为了将来扩展预留的。
- **target**：一个可调用对象，当进程启动时会调用这个对象。如果 `None`，则不调用任何对象。
- **name**：进程的名称。默认情况下，这将是 `Process-N`，其中 `N` 是一个自动递增的整数。
- **args**：传递给 `target` 函数的元组。
- **kwargs**：传递给 `target` 函数的字典。
- **daemon**：如果是 `True`，表示该进程是守护进程。守护进程会在主进程退出时自动终止。

==返回值：==

构造函数本身没有返回值，但是它创建并返回一个 `Process` 对象实例。

==方法:==

`start()`

- **功能**：启动进程，将进程从创建状态切换到运行状态。调用此方法时，进程开始执行其 `run()` 方法，通常是调用 `target` 函数。
- **返回值**：无。

`run()`

- **功能**：定义进程的活动。默认情况下，此方法会调用传递给构造函数的 `target` 函数。如果未指定 `target`，则该方法不执行任何操作。通常不需要直接调用此方法，而是通过 `start()` 方法间接调用。
- **返回值**：无。

`join(timeout=None)`

- **功能**：阻塞当前线程，直到调用该方法的进程终止或超时（如果指定了 `timeout`）。如果 `timeout` 参数为 `None`，该方法将无限期等待。
- **参数**：
  - `timeout`（可选）：等待的最长时间，以秒为单位。如果为 `None`，则无限期等待。
- **返回值**：无。

`terminate()`

- **功能**：强制终止进程。调用此方法会立即停止进程的执行，不能保证进程会安全地清理资源。
- **返回值**：无。

`is_alive()`

- **功能**：检查进程是否仍在运行。返回一个布尔值，指示进程是否还在活动。
- **返回值**：布尔值 `True` 或 `False`。

`close()` 

- **功能**：用于防止更多的数据被添加到进程池或队列中。这是终止池的一部分过程。调用 `close()` 后，将不再接受新的任务提交。
- **返回值**：无

`kill()` 

- **功能**：用于强制终止进程。这是一个立即停止进程执行的方法，与 `terminate()` 类似，但通常更激进，可能不会执行任何清理操作。
- **返回值**：无

==属性:==

- **name**：进程名称。
- **pid**：进程 ID。
- **daemon**：是否是守护进程。
- **exitcode**：进程退出代码。正常退出为 `None`，意外终止时为负数（例如被信号终止）。
- **authkey**：进程的认证密钥。
- **sentinel**：用于进程的可等待哨兵。

## 3.3多进程创建实例

### 3.3.1创建不执行任务的进程

```python
from multiprocessing import *

if __name__ == '__main__':
    # 创建多进程
    p = Process()
    # 运行多进程
    p.start()
    p.join()

```

### 3.3.2创建执行任务的进程

```python
import os
import time
from multiprocessing import *


def process1():
    n = 0
    print(f"子进程 process1 pid = {os.getpid()},ppid = {os.getppid()}")
    while True:
        print("我是子进程")
        time.sleep(1)
        n += 1
        if n == 5:
            exit(0)


if __name__ == "__main__":
    print(f"父进程的pid = {os.getpid()}")
    # 默认情况下，子进程是非守护进程，这意味着主进程会等待所有非守护子进程完成后再退出。
    # 即使父进程没有调用join()方法，只要子进程仍在运行，主进程就不会退出。
    p = Process(target=process1, name="child_process")
    p.start()
    # 阻塞等待子进程结束
    p.join()
    print("子进程退出了")

```

### 3.3.3向进程传递参数

```python
from multiprocessing import Process


def process(who,work):
    print(f"who = {who},work = {work}")
    exit(0)
if __name__ == '__main__':
    p = Process(target=process,args=("zhangsan", "执行进程"))
    p.start()
    p.join()
if __name__ == '__main__':
    p = Process(target=process,kwargs={"who": "zhangsan", "work": "执行进程"})
    p.start()
    p.join()
```


# 1.两大编程思想

编程思想主要包括两大流派：面向过程编程（Procedural Programming）和面向对象编程（Object-Oriented Programming, OOP）。这两种编程思想有着不同的设计原则和实现方式。

## 1.1面向过程编程

（Procedural Programming）

面向过程编程是一种以过程为中心的编程范式，程序通过一系列步骤或过程来解决问题。这种编程思想强调算法和数据的分离，所有操作都是通过函数或过程来完成的。

- **函数和过程**：程序由多个函数或过程组成，每个函数处理一个特定的任务。
- **数据和操作分离**：数据在全局范围内定义，操作数据的函数在数据之外定义。
- **模块化**：通过将程序划分为多个小函数，提高代码的可读性和可维护性。

## 1.2面向对象编程

（Object-Oriented Programming, OOP）

面向对象编程是一种以对象为中心的编程范式，通过创建对象来模拟现实世界中的事物。OOP 强调封装、继承、多态和抽象等原则，使代码更加模块化和可重用。

- **类和对象**：类是对象的蓝图，定义了对象的属性和行为。对象是类的实例。
- **封装**：将数据和操作封装在对象内部，隐藏内部实现细节。
- **继承**：通过继承，可以创建新的类，复用已有类的属性和行为。
- **多态**：不同对象可以对相同的方法作出不同的响应。

# 2.类和对象

## 2.1类是怎么来的？

==类==：是由N多个对象抽取出像的==属性==和==行为==从而归纳总结出来的一种类别。

在Python中一切皆对象

## 2.2类和对象的定义格式

```python
class 类名:   # 这里可以加括号(),也可以省略
    pass

对象=类名()
```

```python
class person:  # 自定义类型
    pass

s = person()   # 实例化对象s
print(type(s))  # <class '__main__.person'>

"""
在 Python 中，<class '__main__.person'> 的 __main__ 表示当前模块（文件）的名#称。具体来说：
__main__：是当前模块的名称，表示这是运行的主程序。当你直接运行一个 Python 文件时，Python 会将这个文件的名称设置为 __main__。如果这个类是在另一个文件中定义并通过导入使用的，则会显示定义类的模块名称，而不是 __main__。
"""
```

## 2.3类的组成及使用

![image-20241031164859894](https://hqyj-note-picture.oss-cn-beijing.aliyuncs.com/picture_bak/mypicture202410311649095.png) 

使用实例 1：

```python
class Person:
    # 类属性：定义在类中，方法外的变量
    city = "china"

    # 初始化方法
    def __init__(self, name, age):
        self.name = name  # 左侧是实例属性，右侧是局部变量
        self.age = age  # 实例属性变量名和局部变量名字可以重复

    # 定义在类中的方法，是实例化方法
    def show(self):
        print(f"name={self.name},age={self.age}")

    # 静态方法，是使用装饰器修饰的
    @staticmethod
    def self_method():
        print(f"这里是静态方法,不能调用实例化属性，也不能调用实例化方法,city = {Person.city}")

    # 类方法，使用装饰器修饰
    @classmethod
    def class_method(cls):
        print(f"这是类方法是，不能够调用实例化属性，也不能调用实例化方法,city = {cls.city}")

print(Person.city)  # 类属性可以通过类名访问的变量，它不属于对象它属于类
p1 = Person("张三", 20)  # 实例化对象
print(type(p1))
p1.show()
p1.self_method()

Person.class_method()

```

> [!CAUTION]
>
> ### 静态方法 (`@staticmethod`)
>
> 静态方法与类和实例无关，它们像普通函数一样工作，但是定义在类的命名空间中。它们不需要访问类的属性或实例的属性。
>
> **特点**：
>
> - 不依赖于类实例或类本身的数据。
> - 不能访问实例属性或类属性。
> - 可以通过类或实例调用。
>
> **定义**：使用 `@staticmethod` 装饰器。
>
> ```python
> class MathUtils:
>     
>     @staticmethod
>     def add(x, y):
>         return x + y
>     
>     @staticmethod
>     def subtract(x, y):
>         return x - y
> 
> # 通过类调用
> print(MathUtils.add(5, 3))       # 输出：8
> print(MathUtils.subtract(10, 7)) # 输出：3
> 
> # 通过实例调用
> math_utils = MathUtils()
> print(math_utils.add(2, 4))      # 输出：6
> ```
>
> ### 类方法 (`@classmethod`)
>
> 类方法是与类本身相关的方法，可以访问类的属性。它们的第一个参数是类本身（通常命名为 `cls`）。
>
> **特点**：
>
> - 操作类本身，而不是实例。
> - 可以访问和修改类属性。
> - 可以通过类或实例调用。
>
> **定义**：使用 `@classmethod` 装饰器。
>
> ```python
> class School:
>     school_name = "Hogwarts"
>     
>     def __init__(self, student_name, grade):
>         self.student_name = student_name
>         self.grade = grade
>     
>     @classmethod
>     def change_school_name(cls, new_name):
>         cls.school_name = new_name
>     
>     @classmethod
>     def get_school_name(cls):
>         return cls.school_name
> 
> # 使用类方法修改类属性
> School.change_school_name("Beauxbatons")
> print(School.get_school_name())  # 输出：Beauxbatons
> 
> # 创建实例并使用类方法
> student = School("Harry Potter", 5)
> print(student.get_school_name())  # 输出：Beauxbatons
> ```
>
> ### 总结
>
> - **静态方法**：不依赖于类实例或类属性，类似于类中的普通函数。用于逻辑与类相关，但不依赖于类的数据。
> - **类方法**：以类为操作对象，可以访问和修改类属性。用于类级别的操作。



使用实例2：

```python
class Student:
    school = "hqyj"

    def __init__(self, name, age=23):
        self.name = name
        self.age = age

    def show(self):
        print(f"name={self.name},age={self.age}")

    @staticmethod
    def static_student():
        print("这是Student的静态方法")

    @classmethod
    def class_student(cls):
        print("这是Student的类方法，可以访问类中的属性和方法")


s1 = Student("zhangsan")
s2 = Student("lisi", 50)
s3 = Student("wangwu")
s4 = Student("tianqi", 18)

lst = [s1, s2, s3, s4]

for item in lst:
    item.show()

```

## 2.4动态绑定属性和方法

```python
class Student:
    school = "hqyj"

    def __init__(self, name, age=23):
        self.name = name
        self.age = age

    def show(self):
        print(f"name={self.name},age={self.age}")

    @staticmethod
    def static_student():
        print("这是Student的静态方法")

    @classmethod
    def class_student(cls):
        print("这是Student的类方法，可以访问类中的属性和方法")


s1 = Student("张三", 20)
s2 = Student("李四", 30)
s2.sex = "m"  # 动态绑定了属性
print(s1.name, s1.age)
print(s2.name, s2.age, s2.sex)


def hello(name):
    print(f"{name} say hello!!!")


s2.hello = hello  # 动态绑定了方法
s2.hello(s2.name)  # 李四 say hello!!!

```

## 2.5封装

### 2.5.1封装的概念

**封装**：隐藏内部细节，对外提供操作方式

### 2.5.2权限控制

权限控制：通过对属性或方法添加单下划线，双下划线以及收尾双下划线来实现。

- 单下划线开头：以但下划线开头的属性或方法表示protected受保护的成员，这些成员被视为仅内部使用，允许类本身和子类进行访问，但实际上它可以被外部代码访问
- 双下划线开头：表示private私有的成员，这类成员允许定义该属性和方法的类本身进行访问。
- 首尾双下划线：一般表示特殊的方法

```python
# 当前文件夹：31类的权限.py
# ======================================

# 定义一个 Student 类
class Student:
    # 构造函数，用于初始化类的实例
    def __init__(self, name, age, sex):
        # 将 name、age 和 sex 参数赋值给实例的 name、_age 和 __sex 属性
        # name 属性是公有的，可以直接访问
        self.name = name  
        # _age 属性是受保护的，可以通过类本身或子类访问，但是也可以强制访问
        self._age = age  
        # __sex 属性是私有的，只能通过类本身访问
        self.__sex = sex  

    # 受保护的方法
    def _fun(self):
        # 打印出“这是受保护的方法”
        print("这是受保护的方法")

    # 私有的方法
    def __fun(self):
        # 打印出“这是私有的方法”
        print("这是私有的方法")

    # 公有的方法
    def show(self):
        # 打印出实例的 name、_age 和 __sex 属性
        print(f"name={self.name},age={self._age},sex={self.__sex}")

# 创建一个 Student 类的实例 s1
s1 = Student("张三", 20, "M")

# 访问实例的 name 属性
print(s1.name)

# 访问实例的 _age 属性（注意：这是受保护的属性）
print(s1._age)  # 警告：访问类的 protected 成员 _age

# 尝试访问实例的 __sex 属性（注意：这是私有的属性）
# print(s1.__sex) #AttributeError: 'Student' object has no attribute '__sex'

# 调用实例的 show 方法
s1.show()

# 调用实例的 _fun 方法（注意：这是受保护的方法）
s1._fun()

# 尝试调用实例的 __fun 方法（注意：这是私有的方法）
# s1.__fun() #AttributeError: 'Student' object has no attribute '__fun'. Did you mean: '_fun'?

# 受保护的一定不能访问吗？答案是否定的
# 可以通过 dir() 函数获取这个类中的所有属性及方法
print(dir(s1))  # ['_Student__fun', '_Student__sex'...

# 访问实例的 __sex 属性（注意：这是私有的属性）
print(s1._Student__sex)  # M

# 调用实例的 __fun 方法（注意：这是私有的方法）
s1._Student__fun()  # 这是私有的方法
```

### 2.5.3属性的设置

`property` 通过装饰器 `@property` 来定义一个属性，之后可以使用 `@<property_name>.setter` 来定义相应的设置方法。这样，用户可以像访问普通属性一样访问这些方法，而不需要直接调用。

```python
# 定义一个 Student 类
class Student:
    # 构造函数，用于初始化类的实例
    # name 和 age 参数用于初始化实例的 name 和 age 属性
    def __init__(self, name, age):
        # 将 name 和 age 参数赋值给实例的 name 和 __age 属性
        # name 属性是公有的，可以直接访问
        self.name = name
        # __age 属性名前面有两个下划线，表示这个属性是私有的，不应该从外部直接访问
        self.__age = age

    # @property 装饰器是将方法当成属性使用
    # age 方法用于获取 __age 属性的值
    # 这样可以通过 s1.age 来访问 __age 属性的值，而不是直接访问 s1.__age
    @property
    def age(self):
        # 返回 __age 属性的值
        return self.__age

    # @age.setter 装饰器是将 age 方法转换为 setter 方法
    # age 方法用于设置 __age 属性的值
    # 这样可以通过 s1.age = 55 来设置 __age 属性的值，而不是直接修改 s1.__age
    @age.setter
    def age(self, age):
        # 将 age 参数赋值给 __age 属性
        self.__age = age


# 创建一个 Student 类的实例 s1
s1 = Student("张三", 22)

# 打印出 s1 的 name 和 age 属性
print(s1.name, s1.age)

# 使用 setter 方法将 s1 的 age 属性设置为 55
s1.age = 55

# 再次打印出 s1 的 name 和 age 属性
print(s1.name, s1.age)

```

## 2.6继承

### 2.6.1继承的概念和语法格式

**继承**：

- 在Python中一个子类可以继承N多个父类
- 一个父类也可以拥有N多个子类
- 如果一个类没有继承任何类，那么这个类默认继承的是object类

**继承的语法结构**：

```python
class 类名(父类1,父类2,...父类N):
    pass
```

### 2.6.2继承的使用实例

```python
# 当前文件夹：继承.py
# ======================================


# 定义一个 Person 类（继承了 object 类）
class Person:
    # 构造函数，用于初始化类的实例
    def __init__(self, name, age):
        # 将 name 和 age 参数赋值给实例的 name 和 age 属性
        # 这两个属性是公有的，可以直接访问
        self.name = name
        self.age = age

    # 公有的方法
    def show(self):
        # 打印出实例的 name 和 age 属性
        print(f"name = {self.name},age = {self.age}")


# 定义一个 Teacher 类（继承了 Person 类）
class Teacher(Person):
    # 构造函数，用于初始化类的实例
    def __init__(self, name, age, salar):
        # 调用父类（Person）的构造函数
        # 这样可以避免重复代码
        super().__init__(name, age)
        # 将 salar 参数赋值给实例的 salar 属性
        # 这个属性是特定于 Teacher 类的
        self.salar = salar


# 定义一个 Student 类（继承了 Person 类）
class Student(Person):
    # 构造函数，用于初始化类的实例
    def __init__(self, name, age, score):
        # 调用父类（Person）的构造函数
        # 这样可以避免重复代码
        super().__init__(name, age)
        # 将 score 参数赋值给实例的 score 属性
        # 这个属性是特定于 Student 类的
        self.score = score


# 创建一个 Teacher 类的实例 t1
t1 = Teacher("张三", 30, 10000)

# 创建一个 Student 类的实例 s1
s1 = Student("李四", 20, 88.3)

# 调用实例 t1 的 show 方法
# 这个方法是从 Person 类继承来的
t1.show()

# 打印出实例 t1 的 salar 属性
# 这个属性是特定于 Teacher 类的
print(t1.salar)

# 调用实例 s1 的 show 方法
# 这个方法是从 Person 类继承来的
s1.show()

# 打印出实例 s1 的 score 属性
# 这个属性是特定于 Student 类的
print(s1.score)

```

### 2.6.3Python中多继承

```python
# 定义一个 Mother 类
class Mother:
    # 构造函数，用于初始化类的实例
    def __init__(self, name):
        # 将 name 参数赋值给实例的 name 属性
        self.name = name

    # 定义一个 show 方法
    def show(self):
        # 打印出 "Mother的show方法"
        print("Mother的show方法")


# 定义一个 Father 类
class Father:
    # 构造函数，用于初始化类的实例
    def __init__(self, age):
        # 将 age 参数赋值给实例的 age 属性
        self.age = age

    # 定义一个 show 方法
    def show(self):
        # 打印出 "Father的show方法"
        print("Father的show方法")


# 定义一个 Son 类，继承了 Mother 类和 Father 类
class Son(Mother, Father):
    # 构造函数，用于初始化类的实例
    def __init__(self, name, age, sex):
        # 调用 Mother 类的构造函数
        Mother.__init__(self, name)
        # 调用 Father 类的构造函数
        Father.__init__(self, age)
        # 将 sex 参数赋值给实例的 sex 属性
        self.sex = sex


# 创建一个 Son 类的实例 s
s = Son("张三", 20, "M")

# 打印出 s 对象的所有属性和方法
print(dir(s))

# 调用 s 对象的 show 方法
# 因为 Mother 和 Father 都有 show 方法，Python 会按顺序解析，调用 Mother 的 show 方法
s.show()
```

### 2.6.4继承方法重写

**方法重写**：

- 子类继承了父类就拥有了父类中公有的成员和受保护的成员
- 父类的方法并不能完全适合子类的需求时，就可以重写父类的方法
- 子类在重写父类的方法是，要求方法的名称必须与父类方法的名称相同，在子类重写后的方法中可以通过super().xxx()调用父类中的方法

```python

# 定义一个 Person 类（继承了 object 类）
class Person:
    # 构造函数，用于初始化类的实例
    def __init__(self, name, age):
        # 将 name 和 age 参数赋值给实例的 name 和 age 属性
        # 这两个属性是公有的，可以直接访问
        self.name = name
        self.age = age

    # 公有的方法
    def show(self):
        # 打印出实例的 name 和 age 属性
        print(f"name = {self.name},age = {self.age}")


# 定义一个 Teacher 类（继承了 Person 类）
class Teacher(Person):
    # 构造函数，用于初始化类的实例
    def __init__(self, name, age, salar):
        # 调用父类（Person）的构造函数
        # 这样可以避免重复代码
        super().__init__(name, age)
        # 将 salar 参数赋值给实例的 salar 属性
        # 这个属性是特定于 Teacher 类的
        self.salar = salar
    def show(self):
        super().show()
        print(f"我的薪水是：{self.salar}")

# 定义一个 Student 类（继承了 Person 类）
class Student(Person):
    # 构造函数，用于初始化类的实例
    def __init__(self, name, age, score):
        # 调用父类（Person）的构造函数
        # 这样可以避免重复代码
        super().__init__(name, age)
        # 将 score 参数赋值给实例的 score 属性
        # 这个属性是特定于 Student 类的
        self.score = score
    def show(self):
        print(f"name = {self.name},age = {self.age},score = {self.score}")

# 创建一个 Teacher 类的实例 t1
t1 = Teacher("张三", 30, 10000)

# 创建一个 Student 类的实例 s1
s1 = Student("李四", 20, 88.3)

# 调用实例 t1 的 show 方法
t1.show()

# 调用实例 s1 的 show 方法
s1.show()


```



## 2.7多态

### 2.7.1多态的概念

**多态**：

- 指的就是"多种形态"即便不知道变量所引用的对象到底是什么，仍然可以通过这个变量调用方法。
- 在程序运行过程中根据变量所引用的对象的数据类型，动态决定调用哪个对象中的方法
- Python语言中的多态，根本不关系对象的数据类型，也不关系类之间是否存在继承关系，只关心对象的行为（方法）。只要不同的类中有同名的方法，可以实现多态

### 2.7.2多态的使用实例

```python
# 定义一个 Person 类
class Person:
    # 定义一个 eat 方法
    def eat(self):
        # 打印出 "人爱吃饭"
        print("人爱吃饭")


# 定义一个 Cat 类
class Cat:
    # 定义一个 eat 方法
    def eat(self):
        # 打印出 "猫爱吃鱼"
        print("猫爱吃鱼")


# 定义一个 fun 函数，接受一个对象作为参数
def fun(obj):
    # 调用对象的 eat 方法
    # 这里使用了多态的概念，obj 可以是任何类的实例，只要它有 eat 方法
    obj.eat()


# 创建一个 Person 类的实例 p
p = Person()

# 创建一个 Cat 类的实例 c
c = Cat()

# 调用 fun 函数，传入 p 对象
fun(p)  # 输出：人爱吃饭

# 调用 fun 函数，传入 c 对象
fun(c)  # 输出：猫爱吃鱼

```

## 2.8object类

**object**:

- 所有类直接或间接的父类
- 所有类都拥有object类的属性和方法

### 2.8.1object中特殊的方法

| object类中特殊的方法 | 功能描述                                            |
| -------------------- | --------------------------------------------------- |
| `__new__()`          | 由系统调用，用于创建对象                            |
| `__init__()`         | 创建对象时手动调用，用于初始化对象属性值            |
| `__str__()`          | 对象的描述，返回值是str类型，默认输出对象的内存地址 |

```python
# 导入正则表达式模块
import re


# 定义一个 Person 类，继承自 object 类
class Person(object):
    # 构造函数，用于初始化类的实例
    def __init__(self, name, age):
        # 将 name 参数赋值给实例的 name 属性
        self.name = name
        # 将 age 参数赋值给实例的 age 属性
        self.age = age

    # 定义一个 show 方法，用于打印实例的信息
    def show(self):
        # 使用 format 方法打印实例的 name 和 age 属性
        print("name={},age={}".format(self.name, self.age))

    # 重写 __str__ 方法，用于获取实例对象的字符串表示
    def __str__(self):
        # 调用 super().__str__() 来获取实例对象的默认字符串表示
        str = super().__str__()
        # 使用正则表达式来匹配内存地址部分
        pattern = r"0x[\da-f]*"
        # 使用 re.search 函数来搜索匹配的字符串
        match = re.search(pattern, str)
        # 返回匹配的字符串，即内存地址部分
        return match.group()


# 创建一个 Person 类的实例 p
p = Person("张三", 20)

# 上述表达式等价于如下两句话
# p = Person.__new__(Person)
# Person.__init__(p,"张三",20)

# 调用 p 实例的 show 方法
p.show()

# 调用 print 函数，打印 p 实例的字符串表示
# 这会调用 Person 类的 __str__ 方法
print(p)  # 重写了 __str__ 方法，只获取地址部分
```

## 2.9特殊方法

![image-20241101162705172](https://hqyj-note-picture.oss-cn-beijing.aliyuncs.com/picture_bak/mypicture202411011627663.png) 

```python
# 定义两个数字变量
a = 100
b = 200

# 使用 dir() 函数获取 a 对象的所有属性和方法
print(dir(a))  # Python中一切皆对象

# 使用特殊方法 __add__ 来进行加法运算
print(a.__add__(b))  # 等价于 a + b

# 使用特殊方法 __sub__ 来进行减法运算
print(a.__sub__(b))  # 等价于 a - b

# 使用特殊方法 __gt__ 来进行大于运算
print(f"a > b吗？", a.__gt__(b))  # 等价于 a > b

# 使用特殊方法 __ge__ 来进行大于或等于运算
print(f"a >= b吗？", a.__ge__(b))  # 等价于 a >= b

# 使用特殊方法 __lt__ 来进行小于运算
print(f"a < b吗？", a.__lt__(b))  # 等价于 a < b

# 使用特殊方法 __le__ 来进行小于或等于运算
print(f"a <= b吗？", a.__le__(b))  # 等价于 a <= b

# 使用特殊方法 __eq__ 来进行等于运算
print(f"a == b吗？", a.__eq__(b))  # 等价于 a == b

# 使用特殊方法 __ne__ 来进行不等于运算
print(f"a != b吗？", a.__ne__(b))  # 等价于 a != b

# 使用特殊方法 __mul__ 来进行乘法运算
print("a * b = ", a.__mul__(b))  # 等价于 a * b

# 使用特殊方法 __truediv__ 来进行除法运算
print("a / b = ", a.__truediv__(b))  # 等价于 a / b

# 使用特殊方法 __floordiv__ 来进行整除运算
print("a // b = ", a.__floordiv__(b))  # 等价于 a // b

# 使用特殊方法 __mod__ 来进行取余运算
print("a % b = ", a.__mod__(b))  # 等价于 a % b
```

## 2.10特殊属性

![image-20241101164058478](https://hqyj-note-picture.oss-cn-beijing.aliyuncs.com/picture_bak/mypicture202411011640850.png) 

```python
# 定义类 A
class A:
    # 构造函数，初始化属性 a
    def __init__(self, a):
        self.a = a

# 定义类 B，继承自 A
class B(A):
    # 构造函数，初始化属性 b 和 a
    def __init__(self, b, a):
        # 调用父类 A 的构造函数
        super().__init__(a)
        self.b = b

# 定义类 C，继承自 B 和 A，解决菱形继承问题
class C(B, A):
    # 构造函数，初始化属性 c、b 和 a
    def __init__(self, c, b, a):
        # 调用父类 B 的构造函数
        super().__init__(b, a)
        self.c = c

# 创建实例 a、b 和 c
a = A(1)
b = B(3, 2)
c = C(6, 5, 4)

# 打印实例的属性
print(a.__dict__)  # {'a': 1}
print(b.__dict__)  # {'a': 2, 'b': 3}
print(c.__dict__)  # {'a': 4, 'b': 5, 'c': 6}

# 打印实例的类
print(a.__class__)  # <class '__main__.A'>
print(b.__class__)  # <class '__main__.B'>
print(c.__class__)  # <class '__main__.C'>

# 分隔线
print("*" * 50)

# 打印类的父类
print(A.__bases__)  # (<class 'object'>,)
print(B.__bases__)  # (<class '__main__.A'>,)
print(C.__bases__)  # (<class '__main__.B'>, <class '__main__.A'>, <class 'object'>)

# 打印类的第一个父类
print(A.__base__)  # <class 'object'>
print(B.__base__)  # <class '__main__.A'>
print(C.__base__)  # <class '__main__.B'>

# 分隔线
print("*" * 50)

# 打印类的方法解析顺序（MRO）
print(A.__mro__)  # (<class '__main__.A'>, <class 'object'>)
print(B.__mro__)  # (<class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
print(C.__mro__)  # (<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)

# 打印类的子类
print(A.__subclasses__())  # [<class '__main__.B'>, <class '__main__.C'>]
print(B.__subclasses__())  # [<class '__main__.C'>]
print(C.__subclasses__())  # []
```

## 2.11类的深浅拷贝

![image-20241101173308000](https://hqyj-note-picture.oss-cn-beijing.aliyuncs.com/picture_bak/mypicture202411011733999.png)

```python
# 定义一个 Person 类
class Person:
    pass


# 定义一个 Student 类
class Student:
    # 构造函数，初始化属性 per
    def __init__(self, p):
        self.per = p


# 创建一个 Person 对象 p
p = Person()
print(p)  # <__main__.Person object at 0x108621370>
# 创建一个 Student 对象 s1，并将 p 作为其属性 per
s1 = Student(p)

# 输出 s1 对象和其 per 属性
print(
    s1, s1.per
)  # <__main__.Student object at 0x108621310> <__main__.Person object at 0x108621370>

# 将 s1 对象的引用赋给 s2
s2 = s1

# 输出 s2 对象和其 per 属性
print(
    s2, s2.per
)  # <__main__.Student object at 0x108621310> <__main__.Person object at 0x108621370>

# 导入 copy 模块
import copy

# 使用 copy.copy() 函数创建 s2 对象的浅拷贝 s3
s3 = copy.copy(s2)

# 输出 s3 对象和其 per 属性
print(
    s3, s3.per
)  # <__main__.Student object at 0x108621490> <__main__.Person object at 0x108621370>

# 使用 copy.deepcopy() 函数创建 s2 对象的深拷贝 s4
s4 = copy.deepcopy(s2)

# 输出 s4 对象和其 per 属性
print(
    s4, s4.per
)  # <__main__.Student object at 0x108623dd0> <__main__.Person object at 0x108623e90>

```

